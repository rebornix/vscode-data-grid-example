import * as vscode from "vscode";
import { KernelMessage, Kernel, Session } from "@jupyterlab/services";
import { IKernelConnectionInfo, KernelConnectionMetadataWithKernelSpecs } from "./jupyterAPI";

export function cleanStackTrace(frames: string[]) {
    return frames.map((frame) =>
        frame
            .split("\n")
            .filter((line) => {
                const clean = stripAnsi(line);

                // TODO@DW: we should make sure that it's okay to just drop these lines from stack traces
                // for debugging errors, the full traces will always show up in the console still.
                if (clean.includes("__DW_") || clean.includes('exec("""')) {
                    return false;
                }
                return true;
            })
            .join("\n")
    );
}

export function ansiRegex({ onlyFirst = false } = {}) {
    const pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"
    ].join("|");

    return new RegExp(pattern, onlyFirst ? undefined : "g");
}

export function stripAnsi(s: string) {
    if (typeof s !== "string") {
        throw new TypeError(`Expected a \`string\`, got \`${typeof s}\``);
    }

    return s.replace(ansiRegex(), "");
}

export function stripAnsiDeep<T>(obj: T): T {
    return JSON.parse(JSON.stringify(obj, (_, value) => (typeof value === "string" ? stripAnsi(value) : value)));
}

export enum KernelSessionType {
    JupyterLab = "JupyterLab",
    VSCodeJupyter = "VSCodeJupyter"
}

export interface IKernelSession {
    id: string;
    name: string;
    type: KernelSessionType;
    executeCode: (
        code: string,
        options?: {
            outputStream?: any;
        }
    ) => Promise<string>;
    interrupt: () => Promise<void>;
    onStatusChanged: vscode.Event<Kernel.Status>;
}


/**
 * Jupyter implementation of the kernel session.
 */
export class VSCJupyterKernelSession implements IKernelSession {
    /** ID of the kernel session. */
    public id: string;

    /** Name of the kernel session. */
    public name: string;

    /** Type of kernel session. */
    public type = KernelSessionType.VSCodeJupyter;

    private onStatusChangedEvent: vscode.EventEmitter<Kernel.Status> = new vscode.EventEmitter<Kernel.Status>();

    constructor(
        private connectionInfo: IKernelConnectionInfo,
        specs: KernelConnectionMetadataWithKernelSpecs
    ) {
        this.connectionInfo.connection.statusChanged.connect(this.onKernelStatus, this);
        this.onStatusChanged = this.onStatusChangedEvent.event;
        this.id = specs.id;
        this.name = specs.kernelSpec?.display_name ?? specs.id;
    }

    /**
     * Event listener for kernel status changes.
     */
    public onStatusChanged: vscode.Event<any>;

    private onKernelStatus(_sender: Kernel.IKernelConnection, state: Kernel.Status) {
        this.onStatusChangedEvent.fire(state);
    }

    private async executeRequest(
        code: string,
        handleMessage: (message: KernelMessage.IMessage) => void
    ): Promise<void> {
        // create a new execution request
        const executeRequest = this.connectionInfo.connection.requestExecute({
            code,
            store_history: false
        });

        let canceled = false;
        executeRequest.onIOPub = (message: KernelMessage.IIOPubMessage) => {
            if (KernelMessage.isErrorMsg(message)) {
                if (message.content.ename === "KeyboardInterrupt") {
                    canceled = true;
                }
            }
            handleMessage(message);
        };
        executeRequest.onReply = (message: KernelMessage.IExecuteReplyMsg) => {
            handleMessage(message);
        };

        await executeRequest.done;

        if (canceled) {
            throw new Error("Canceled");
        }
    }

    /**
     * Executes the given code.
     */
    public async executeCode(
        code: string,
        options?: {
            outputStream?: any;
        }
    ): Promise<string> {
        // return the stdout as a newline-joined string
        const resultSoFar: string[] = [];
        let errorMessage;
        let errorType;
        let errorTrace: string[] = [];

        await this.executeRequest(code, (message: KernelMessage.IMessage) => {
            if (KernelMessage.isStreamMsg(message)) {
                // ignore stderr
                if (message.content.name === "stderr") {
                    // TODO@DW: consider adding telemetry for warnings generated by us?
                    console.warn(message.content.text);
                } else {
                    resultSoFar.push(message.content.text);
                }

                // optionally handle pass output messages to the host
                options?.outputStream?.(message.content.text);
            } else if (KernelMessage.isErrorMsg(message)) {
                console.error(code, stripAnsiDeep(message.content));
                errorMessage = message.content.evalue;
                errorType = message.content.ename;
                errorTrace = message.content.traceback;
            } else if (KernelMessage.isExecuteReplyMsg(message) && message.content.status === "error") {
                errorMessage = message.content.evalue;
                errorType = message.content.ename;
                errorTrace = message.content.traceback;
            }
        });

        if (errorMessage && errorType) {
            const error = {
                name: errorType,
                message: errorMessage,
                stack: cleanStackTrace(errorTrace)
            };
            throw error;
        }

        return resultSoFar.join("\n");
    }

    public interrupt() {
        return this.connectionInfo.connection.interrupt();
    }

    /**
     * Disposes the kernel session.
     */
    public dispose() {
        this.connectionInfo.connection.dispose();
    }
}



